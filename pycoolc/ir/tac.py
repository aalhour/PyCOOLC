#!/usr/bin/env python3

"""
Three-Address Code (TAC) Intermediate Representation for COOL.

# What is Three-Address Code?

Three-Address Code is an intermediate representation where each instruction
has at most three operands (addresses). The general form is:

    x = y op z      (binary operation)
    x = op y        (unary operation)
    x = y           (copy)

The key insight is that complex expressions are broken down into simple
operations using temporary variables:

    COOL:       a + b * c
    TAC:        t1 = b * c
                t2 = a + t1

# Why TAC for Optimization?

1. **Uniform structure**: Every instruction has the same simple form,
   making pattern matching easy.

2. **Explicit temporaries**: All intermediate values have names,
   making data flow explicit.

3. **No nested expressions**: Each operation is atomic, simplifying
   analysis.

4. **Close to machine code**: Easy translation to assembly, but still
   high-level enough for optimization.

# TAC Instruction Categories

1. **Computation**: Binary ops, unary ops, copies
2. **Control flow**: Labels, jumps, conditional jumps
3. **Memory**: Load, store (for objects)
4. **Procedures**: Call, return, parameter passing
5. **COOL-specific**: New object, dispatch, isvoid

# Operands

Operands in TAC can be:
- **Temporaries**: t0, t1, t2, ... (compiler-generated)
- **Variables**: User-defined identifiers
- **Constants**: Integer, string, boolean literals
- **Labels**: Jump targets

"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Iterator


# =============================================================================
#                           OPERAND TYPES
# =============================================================================


class Operand(ABC):
    """Base class for TAC operands."""
    
    @abstractmethod
    def __str__(self) -> str:
        """String representation for printing."""
        pass


@dataclass(frozen=True, slots=True)
class Temp(Operand):
    """
    A temporary variable generated by the compiler.
    
    Temporaries hold intermediate values during expression evaluation.
    In SSA form, each temporary is assigned exactly once.
    
    Example:
        t0 = a + b
        t1 = t0 * c
    """
    index: int
    
    def __str__(self) -> str:
        return f"t{self.index}"


@dataclass(frozen=True, slots=True)
class Var(Operand):
    """
    A named variable (user-defined or special like 'self').
    
    Variables correspond to:
    - Local variables in let/case expressions
    - Method parameters
    - Class attributes (accessed via self)
    - The special 'self' reference
    """
    name: str
    
    def __str__(self) -> str:
        return self.name


@dataclass(frozen=True, slots=True)
class Const(Operand):
    """
    A constant value (integer, string, or boolean).
    
    Constants are immutable and their values are known at compile time.
    """
    value: int | str | bool
    cool_type: str  # "Int", "String", or "Bool"
    
    def __str__(self) -> str:
        if isinstance(self.value, str):
            # Escape for readability
            escaped = self.value.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")
            return f'"{escaped}"'
        elif isinstance(self.value, bool):
            return "true" if self.value else "false"
        else:
            return str(self.value)


@dataclass(frozen=True, slots=True)
class Label(Operand):
    """
    A label marking a position in the code.
    
    Labels are targets for jump instructions. They don't generate code
    themselves but provide addresses for control flow.
    """
    name: str
    
    def __str__(self) -> str:
        return self.name


# =============================================================================
#                           OPERATOR TYPES
# =============================================================================


class BinOp(Enum):
    """Binary operators in TAC."""
    ADD = auto()   # +
    SUB = auto()   # -
    MUL = auto()   # *
    DIV = auto()   # /
    LT = auto()    # <
    LE = auto()    # <=
    EQ = auto()    # =
    
    def __str__(self) -> str:
        return {
            BinOp.ADD: "+",
            BinOp.SUB: "-",
            BinOp.MUL: "*",
            BinOp.DIV: "/",
            BinOp.LT: "<",
            BinOp.LE: "<=",
            BinOp.EQ: "==",
        }[self]


class UnaryOp(Enum):
    """Unary operators in TAC."""
    NEG = auto()   # ~ (integer negation)
    NOT = auto()   # not (boolean negation)
    
    def __str__(self) -> str:
        return {
            UnaryOp.NEG: "~",
            UnaryOp.NOT: "not",
        }[self]


# =============================================================================
#                           TAC INSTRUCTIONS
# =============================================================================


class Instruction(ABC):
    """
    Base class for all TAC instructions.
    
    Each instruction knows:
    - What variables it defines (writes to)
    - What variables it uses (reads from)
    
    This information is essential for data flow analysis.
    """
    
    @abstractmethod
    def __str__(self) -> str:
        """Human-readable representation."""
        pass
    
    @abstractmethod
    def defs(self) -> set[Operand]:
        """Variables defined (written) by this instruction."""
        pass
    
    @abstractmethod
    def uses(self) -> set[Operand]:
        """Variables used (read) by this instruction."""
        pass
    
    def is_jump(self) -> bool:
        """Does this instruction transfer control?"""
        return False
    
    def is_label(self) -> bool:
        """Is this a label (jump target)?"""
        return False
    
    def jump_targets(self) -> list[Label]:
        """Labels this instruction might jump to."""
        return []


# -----------------------------------------------------------------------------
#                     Computation Instructions
# -----------------------------------------------------------------------------


@dataclass(slots=True)
class BinaryOp(Instruction):
    """
    Binary operation: dest = left op right
    
    Example:
        t0 = a + b
        t1 = x * 2
    """
    dest: Temp | Var
    op: BinOp
    left: Operand
    right: Operand
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.left} {self.op} {self.right}"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        result: set[Operand] = set()
        if isinstance(self.left, (Temp, Var)):
            result.add(self.left)
        if isinstance(self.right, (Temp, Var)):
            result.add(self.right)
        return result


@dataclass(slots=True)
class UnaryOperation(Instruction):
    """
    Unary operation: dest = op operand
    
    Example:
        t0 = ~x      (integer complement)
        t1 = not b   (boolean negation)
    """
    dest: Temp | Var
    op: UnaryOp
    operand: Operand
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.op} {self.operand}"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        if isinstance(self.operand, (Temp, Var)):
            return {self.operand}
        return set()


@dataclass(slots=True)
class Copy(Instruction):
    """
    Copy instruction: dest = source
    
    Copies the value from source to dest. This is the simplest
    instruction and is often the target of copy propagation.
    
    Example:
        x = y
        t0 = 42
    """
    dest: Temp | Var
    source: Operand
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.source}"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        if isinstance(self.source, (Temp, Var)):
            return {self.source}
        return set()


# -----------------------------------------------------------------------------
#                     Control Flow Instructions
# -----------------------------------------------------------------------------


@dataclass(slots=True)
class LabelInstr(Instruction):
    """
    Label definition: marks a position in the code.
    
    Labels don't execute; they just provide addresses for jumps.
    
    Example:
        loop_start:
        if_else:
    """
    label: Label
    
    def __str__(self) -> str:
        return f"{self.label}:"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        return set()
    
    def is_label(self) -> bool:
        return True


@dataclass(slots=True)
class Jump(Instruction):
    """
    Unconditional jump: goto label
    
    Transfers control to the instruction after the label.
    
    Example:
        goto loop_start
    """
    target: Label
    
    def __str__(self) -> str:
        return f"goto {self.target}"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        return set()
    
    def is_jump(self) -> bool:
        return True
    
    def jump_targets(self) -> list[Label]:
        return [self.target]


@dataclass(slots=True)
class CondJump(Instruction):
    """
    Conditional jump: if condition goto label
    
    Jumps to label if condition is true, otherwise falls through
    to the next instruction.
    
    Example:
        if t0 goto loop_body
    """
    condition: Operand
    target: Label
    
    def __str__(self) -> str:
        return f"if {self.condition} goto {self.target}"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        if isinstance(self.condition, (Temp, Var)):
            return {self.condition}
        return set()
    
    def is_jump(self) -> bool:
        return True
    
    def jump_targets(self) -> list[Label]:
        return [self.target]


@dataclass(slots=True)
class CondJumpNot(Instruction):
    """
    Conditional jump (negated): if not condition goto label
    
    Jumps to label if condition is false.
    
    Example:
        ifnot t0 goto loop_end
    """
    condition: Operand
    target: Label
    
    def __str__(self) -> str:
        return f"ifnot {self.condition} goto {self.target}"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        if isinstance(self.condition, (Temp, Var)):
            return {self.condition}
        return set()
    
    def is_jump(self) -> bool:
        return True
    
    def jump_targets(self) -> list[Label]:
        return [self.target]


# -----------------------------------------------------------------------------
#                     Procedure Instructions
# -----------------------------------------------------------------------------


@dataclass(slots=True)
class Param(Instruction):
    """
    Parameter passing: param x
    
    Pushes a value onto the parameter stack before a call.
    Parameters are pushed in order (first param first).
    
    Example:
        param t0
        param t1
        call foo, 2
    """
    value: Operand
    
    def __str__(self) -> str:
        return f"param {self.value}"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        if isinstance(self.value, (Temp, Var)):
            return {self.value}
        return set()


@dataclass(slots=True)
class Call(Instruction):
    """
    Function/method call: dest = call target, n
    
    Calls a function with n parameters (previously pushed with param).
    The result (if any) is stored in dest.
    
    Example:
        t0 = call factorial, 1
    """
    dest: Temp | Var | None  # None if return value is discarded
    target: str  # Function/method name (or label)
    num_args: int
    
    def __str__(self) -> str:
        if self.dest:
            return f"{self.dest} = call {self.target}, {self.num_args}"
        else:
            return f"call {self.target}, {self.num_args}"
    
    def defs(self) -> set[Operand]:
        if self.dest:
            return {self.dest}
        return set()
    
    def uses(self) -> set[Operand]:
        # Parameters are used, but tracked via Param instructions
        return set()


@dataclass(slots=True)
class Return(Instruction):
    """
    Return from function: return x
    
    Returns control to the caller with optional return value.
    
    Example:
        return t0
        return      (void return, or return self in COOL)
    """
    value: Operand | None = None
    
    def __str__(self) -> str:
        if self.value:
            return f"return {self.value}"
        else:
            return "return"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        if self.value and isinstance(self.value, (Temp, Var)):
            return {self.value}
        return set()
    
    def is_jump(self) -> bool:
        # Return is a control flow instruction (exits function)
        return True


# -----------------------------------------------------------------------------
#                     COOL-Specific Instructions
# -----------------------------------------------------------------------------


@dataclass(slots=True)
class New(Instruction):
    """
    Object allocation: dest = new Type
    
    Allocates a new object of the given type and initializes it.
    
    Example:
        t0 = new Foo
        t1 = new SELF_TYPE
    """
    dest: Temp | Var
    type_name: str
    
    def __str__(self) -> str:
        return f"{self.dest} = new {self.type_name}"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        return set()


@dataclass(slots=True)
class Dispatch(Instruction):
    """
    Dynamic method dispatch: dest = obj.method(args)
    
    Calls a method on an object using dynamic dispatch (vtable lookup).
    
    Example:
        t0 = self.foo(t1, t2)
    
    Note: Arguments are pushed via Param before this instruction.
    """
    dest: Temp | Var | None
    obj: Operand
    method: str
    num_args: int
    
    def __str__(self) -> str:
        if self.dest:
            return f"{self.dest} = {self.obj}.{self.method}({self.num_args} args)"
        else:
            return f"{self.obj}.{self.method}({self.num_args} args)"
    
    def defs(self) -> set[Operand]:
        if self.dest:
            return {self.dest}
        return set()
    
    def uses(self) -> set[Operand]:
        result: set[Operand] = set()
        if isinstance(self.obj, (Temp, Var)):
            result.add(self.obj)
        return result


@dataclass(slots=True)
class StaticDispatch(Instruction):
    """
    Static method dispatch: dest = obj@Type.method(args)
    
    Calls a method using static dispatch (specific class's method).
    
    Example:
        t0 = self@Parent.foo(t1)
    """
    dest: Temp | Var | None
    obj: Operand
    static_type: str
    method: str
    num_args: int
    
    def __str__(self) -> str:
        if self.dest:
            return f"{self.dest} = {self.obj}@{self.static_type}.{self.method}({self.num_args} args)"
        else:
            return f"{self.obj}@{self.static_type}.{self.method}({self.num_args} args)"
    
    def defs(self) -> set[Operand]:
        if self.dest:
            return {self.dest}
        return set()
    
    def uses(self) -> set[Operand]:
        result: set[Operand] = set()
        if isinstance(self.obj, (Temp, Var)):
            result.add(self.obj)
        return result


@dataclass(slots=True)
class IsVoid(Instruction):
    """
    Void check: dest = isvoid expr
    
    Tests if an expression evaluates to void (null).
    
    Example:
        t0 = isvoid t1
    """
    dest: Temp | Var
    operand: Operand
    
    def __str__(self) -> str:
        return f"{self.dest} = isvoid {self.operand}"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        if isinstance(self.operand, (Temp, Var)):
            return {self.operand}
        return set()


@dataclass(slots=True)
class GetAttr(Instruction):
    """
    Attribute load: dest = obj.attr
    
    Loads an attribute from an object.
    
    Example:
        t0 = self.x
    """
    dest: Temp | Var
    obj: Operand
    attr: str
    
    def __str__(self) -> str:
        return f"{self.dest} = {self.obj}.{self.attr}"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        if isinstance(self.obj, (Temp, Var)):
            return {self.obj}
        return set()


@dataclass(slots=True)
class SetAttr(Instruction):
    """
    Attribute store: obj.attr = value
    
    Stores a value into an object's attribute.
    
    Example:
        self.x = t0
    """
    obj: Operand
    attr: str
    value: Operand
    
    def __str__(self) -> str:
        return f"{self.obj}.{self.attr} = {self.value}"
    
    def defs(self) -> set[Operand]:
        # Technically modifies memory, not a register
        return set()
    
    def uses(self) -> set[Operand]:
        result: set[Operand] = set()
        if isinstance(self.obj, (Temp, Var)):
            result.add(self.obj)
        if isinstance(self.value, (Temp, Var)):
            result.add(self.value)
        return result


# -----------------------------------------------------------------------------
#                     SSA-Specific Instructions
# -----------------------------------------------------------------------------


@dataclass(slots=True)
class Phi(Instruction):
    """
    SSA φ-function: dest = φ(val1, val2, ...)
    
    A φ-function selects a value based on which predecessor block
    control flow came from. It's the key to SSA form.
    
    Example:
        At a join point after an if-else:
        x3 = φ(x1, x2)
        
        Where x1 is the value if we came from the then-branch,
        and x2 is the value if we came from the else-branch.
    
    Note: φ-functions are inserted during SSA construction and
    removed during SSA destruction before code generation.
    """
    dest: Temp | Var
    sources: list[tuple[Operand, Label]]  # (value, predecessor_label) pairs
    
    def __str__(self) -> str:
        args = ", ".join(f"{v}[{lbl}]" for v, lbl in self.sources)
        return f"{self.dest} = φ({args})"
    
    def defs(self) -> set[Operand]:
        return {self.dest}
    
    def uses(self) -> set[Operand]:
        result: set[Operand] = set()
        for val, _ in self.sources:
            if isinstance(val, (Temp, Var)):
                result.add(val)
        return result


# =============================================================================
#                           TAC PROGRAM
# =============================================================================


@dataclass
class TACMethod:
    """
    A method represented in TAC form.
    
    Contains all the instructions for a single method, plus metadata
    like the method name, class, parameters, and local variables.
    """
    class_name: str
    method_name: str
    params: list[str]
    instructions: list[Instruction] = field(default_factory=list)
    
    def __str__(self) -> str:
        lines = [f"method {self.class_name}.{self.method_name}({', '.join(self.params)}):"]
        for instr in self.instructions:
            if isinstance(instr, LabelInstr):
                lines.append(f"  {instr}")
            else:
                lines.append(f"    {instr}")
        return "\n".join(lines)
    
    def __iter__(self) -> Iterator[Instruction]:
        return iter(self.instructions)


@dataclass
class TACProgram:
    """
    A complete COOL program in TAC form.
    
    Contains all methods organized by class, plus global data like
    string constants.
    """
    methods: list[TACMethod] = field(default_factory=list)
    string_constants: dict[str, str] = field(default_factory=dict)  # value -> label
    
    def __str__(self) -> str:
        lines = ["# TAC Program", ""]
        
        if self.string_constants:
            lines.append("# String Constants:")
            for value, label in self.string_constants.items():
                escaped = value.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")
                lines.append(f"  {label}: \"{escaped}\"")
            lines.append("")
        
        for method in self.methods:
            lines.append(str(method))
            lines.append("")
        
        return "\n".join(lines)
    
    def get_method(self, class_name: str, method_name: str) -> TACMethod | None:
        """Find a method by class and name."""
        for method in self.methods:
            if method.class_name == class_name and method.method_name == method_name:
                return method
        return None


# =============================================================================
#                           TEMPORARY GENERATOR
# =============================================================================


class TempGenerator:
    """
    Generates unique temporary variable names.
    
    Used during AST-to-IR translation to create temporaries
    for intermediate values.
    """
    
    def __init__(self) -> None:
        self._counter = 0
    
    def next(self) -> Temp:
        """Generate a fresh temporary."""
        temp = Temp(self._counter)
        self._counter += 1
        return temp
    
    # Alias for compatibility
    new_temp = next
    
    def reset(self) -> None:
        """Reset counter (for testing)."""
        self._counter = 0


class LabelGenerator:
    """
    Generates unique label names.
    
    Used during AST-to-IR translation to create labels
    for control flow.
    """
    
    def __init__(self) -> None:
        self._counter = 0
    
    def next(self, hint: str = "") -> Label:
        """Generate a fresh label with optional hint prefix."""
        prefix = hint if hint else "L"
        label = Label(f"{prefix}_{self._counter}")
        self._counter += 1
        return label
    
    # Alias for compatibility
    new_label = next
    
    def reset(self) -> None:
        """Reset counter (for testing)."""
        self._counter = 0


@dataclass(slots=True)
class Comment(Instruction):
    """
    A comment in the TAC code.
    
    Comments are for debugging and don't generate code.
    """
    text: str
    
    def __str__(self) -> str:
        return f"# {self.text}"
    
    def defs(self) -> set[Operand]:
        return set()
    
    def uses(self) -> set[Operand]:
        return set()

